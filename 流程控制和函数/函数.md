<!-- TOC -->

- [函数详解](#函数详解)
	- [函数声明语法](#函数声明语法)
	- [函数特点](#函数特点)
		- [自定义函数类型](#自定义函数类型)
	- [函数参数传递的方式](#函数参数传递的方式)
	- [命名函数返回值的名称](#命名函数返回值的名称)
	- [可变参数](#可变参数)
		- [可变参数练习](#可变参数练习)
	- [defer的定义](#defer的定义)
	- [defer的用途](#defer的用途)
		- [关闭文件句柄](#关闭文件句柄)
		- [锁资源释放](#锁资源释放)
		- [数据库连接释放](#数据库连接释放)
	- [匿名函数定义](#匿名函数定义)
- [课后作业](#课后作业)
	- [九九乘法表](#九九乘法表)
	- [一个数如果恰好等于它的因子之和，这个数称为"完数"，例如6=1+2+3，编程找出1000以内的完数](#一个数如果恰好等于它的因子之和这个数称为完数例如6123编程找出1000以内的完数)
	- [输入一个字符串，判断是否是回文，回文字符串是指从左到右读和从右到左读完全相同的字符串](#输入一个字符串判断是否是回文回文字符串是指从左到右读和从右到左读完全相同的字符串)
	- [输入一行字符，分别统计出其中英文字母，空格，数字和其他字符的个数](#输入一行字符分别统计出其中英文字母空格数字和其他字符的个数)
	- [计算俩个大数相加的和，这俩个大数会超过int64的表示范围](#计算俩个大数相加的和这俩个大数会超过int64的表示范围)

<!-- /TOC -->
# 函数详解
## 函数的声明和注释

```go
1.函数声明：func 函数名称（参数列表）（返回值列表）{}
// 举例：
func add(){}
func add(a int,b int) int {}
func add(a int,b int) (int,int) {}

2.注释，俩种注释，单行注释：//和多行注释/**/
```

## 函数声明语法

    func 函数名（参数列表）[(返回值列表)]{}
```go
// example1:
func add(){
}
// example2:
func add(a int,b int){
}
// example3:
func add(a int,b int) int {
}
// example4:
func add(a int,b int)(int,int){
}
// example5:
func add(a,b int)(int,int){
}
```
## 函数特点
```
golang函数特点：
1. 不支持重载，一个包不能有俩个一样名字的函数
2. 函数是一等公民，函数也是一种类型，一个函数可以赋值给变量
3. 匿名函数
4. 多返回值
```
### 自定义函数类型
```go
package main

import "fmt"

// 1、函数是可以赋值给一个变量的
func add(a, b int) int {
	return a + b
}
func func1_main() {
	c := add
	fmt.Println(c)   //这个变量打印出来的值就是一个地址
	sum := c(10, 20) //可以直接为c这个变量添加参数进行获取函数返回的结果
	fmt.Println(sum)
}

// 2、自定义函数类型
//1-// type op_func func(int, int) int //自定义一个函数类型op_func，传入值为int,int，返回值为int

func add2(a, b int) int {
	return a - b
}

//1-// func operator(op op_func, a, b int) int {
func operator(op func(int, int) int, a, b int) int { //也可以使用把函数当做类型传入
	return op(a, b)
}
func func2_main() {
	c := add2
	sum2 := operator(c, 100, 2000) //传入函数，和俩个值
	fmt.Println(sum2)
}

func main() {
	func1_main()
	func2_main()
}

```
## 函数参数传递的方式
>值传递、引用传递（map,clice,chan,指针,interface默认是引用传递）

**注意：**
1. 无论是值传递，还是引用传递，传递给函数的都是变量的副本。
2. 值传递是值的拷贝，引用传递是地址的拷贝
3. 地址拷贝更为高效，而值拷贝取决于拷贝对象的大小，对象越大，性能越低
## 命名函数返回值的名称
	注意：返回值定义了变量，在函数体就无需定义相同的变量了，可以直接去赋值
```go
func add(a int, b int) (c int) { //可以在返回值定义变量
	c = a + b //这里c就不用定义了，直接赋值
	return
}
func calc(a, b int) (sum int, avg int) {
	sum = a + b
	avg = (a + b) / 2
	return
}

func main() {
	add1 := add(10, 20)
	calc1, _ := calc(100, 200)  //_标识符，用来忽略返回值
	fmt.Println(add1, calc1)
}
```
## 可变参数
```go
func add(arg...int) int{} //0个或者多个参数，arg是个自定义名字

func add(a int,arg...int) int{} //1个或者多个参数

func add(a int,b int,arg...int) int() //2个或者多个参数
注意：其中arg是一个slice，我们可以通过arg[index]依次访问所有参数，通过len(arg)来判断传递参数的个数。
```
### 可变参数练习
```golang
package main

import "fmt"
//14、写一个函数add,支持1个或多个int相加，并返回相加结果
func adds(a int, bs ...int) (sum int) {
	sum = a
	for i := 0; i < len(bs); i++ {
		sum = sum + bs[i]
	}
	return
}
func sums_main() {
	sums := adds(1, 123, 123, 43, 412)
	fmt.Println(sums)
}

//15、写一个concat，支持1个或者多个string相拼接，并返回结果
func concat(a string, bs ...string) (concats string) {
	concats = a
	for i := 0; i < len(bs); i++ {
		concats = concats + bs[i]
	}
	return
}
func concat_main() {
	concats := concat("lll", "qqq", "xxx", "www")
	fmt.Println(concats)
}
func main() {
	sums_main()
	concat_main()
}
```
## defer的定义
1. 当函数返回时，执行defer语句，因此，可以用来做资源清理
2. 多个defer语句，按先进后出的方式执行
3. defer语句中的变量，在defer声明时就决定了

```go
package main
import ("fmt")
func defer1() {
	var i int = 0
	defer fmt.Println(i)        //函数执行完后才执行,因此defer的执行结果是0，而不是10，第二执行
	defer fmt.Println("second") //执行顺序，函数返回结果后，第一执行，遵守先进后出的原则
	i = 10
	fmt.Println(i)
}
func main() {
	defer1()
}
```
## defer的用途
### 关闭文件句柄
```go
func read(){
	file := open(filename)
	defer file.Close()
	//文件操作
}
```
### 锁资源释放
```go
func read(){
	mc.Lock()
	defer mc.Unlock()
	//其他操作
}
```
### 数据库连接释放
```go
func read(){
	conn := openDatabase()
	defer conn.Close()
}
```
## 匿名函数定义
```go
//全局定义匿名函数
var (
	result = func(a1 int,b1 int)int {
		resturn a1+b1
	}
)
//函数内部定义匿名函数
func test(a,b int) int {
	result = func(a1 int,b1 int) int {
		return a1+b1
	}
	return result(a,b)
}
```
# 课后作业

## 一个数如果恰好等于它的因子之和，这个数称为"完数"，例如6=1+2+3，编程找出1000以内的完数

## 输入一个字符串，判断是否是回文，回文字符串是指从左到右读和从右到左读完全相同的字符串

## 输入一行字符，分别统计出其中英文字母，空格，数字和其他字符的个数
## 计算俩个大数相加的和，这俩个大数会超过int64的表示范围
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

//1. 九九乘法表
func jj9() {
	for i := 1; i <= 9; i++ {
		for j := 1; j <= i; j++ {
			product := i * j
			fmt.Printf("%d*%d=%d\t", i, j, product)
		}
		fmt.Printf("\n")
	}
}

//2. 一个数如果恰好等于它的因子之和，这个数称为"完数"，例如6=1+2+3，编程找出1000以内的完数
func ws2() {
	for i := 1; i <= 100000; i++ {
		var sum int
		for j := 1; j <= (i / 2); j++ {
			if i%j == 0 {
				sum += j
			}
		}
		if sum == i {
			fmt.Println(sum)
		}

	}
}

//3. 输入一个字符串，判断是否是回文，回文字符串是指从左到右读和从右到左读完全相同的字符串
// > 新知识点：[]rune(str_a)
func strs() {
	var str_a string
	for {
		fmt.Scanf("%s", &str_a)
		t := []rune(str_a) //rune表示一个字符,比如一个汉字字符占用3个字节
		length := len(t)
		for i, _ := range t {
			if i == length/2 {
				break
			}
			last := length - i - 1
			if t[i] != t[last] {
				fmt.Println("no")
			}
		}
		fmt.Println("yes")
		
		//第二种方式，不适用与中文
		// var str_rev string
		// for i := len(str_a) - 1; i >= 0; i-- {
		// 	str_rev += fmt.Sprintf("%c", str_a[i])
		// }
		// if str_a == str_rev {
		// 	fmt.Printf("string true---%s\n", str_rev)
		// } else {
		// 	fmt.Printf("string false---%s\n", str_rev)
		// 	break
		// }
	}
}

//4. 输入一行字符，分别统计出其中英文字母，空格，数字和其他字符的个数
// >新函数,[]rune(),bufio.NewReader(os.Stdin),reader.ReadLine()
func count4(str string) (worldCount, spaceCount, numberCount, otherCount int) {
	t := []rune(str) //表示一个字符
	for _, v := range t {
		switch {
		case v >= 'a' && v <= 'z':
			fallthrough
		case v >= 'A' && v <= 'Z':
			worldCount++
		case v == ' ':
			spaceCount++
		case v >= '0' && v <= '9':
			numberCount++
		default:
			otherCount++
		}
	}
	return
}
func read_line() {
	reader := bufio.NewReader(os.Stdin) //终端输入
	result, _, err := reader.ReadLine() //读取行
	if err != nil {
		fmt.Println("read form console err:", err)
		return
	}
	wc, sc, nc, oc := count4(string(result))
	fmt.Printf("worldcount:%d\nspacecount:%d\nnumvercount:%d\nothercount:%d\n", wc, sc, nc, oc)

}

//5. 计算俩个大数相加的和，这俩个大数会超过int64的表示范围
func multi(str1, str2 string) (result string) {
	if len(str1) == 0 && len(str2) == 0 {
		result = "0"
		return
	}
	var index1 = len(str1) - 1
	var index2 = len(str2) - 1
	var left int
	for index1 >= 0 && index2 >= 0 {
		c1 := str1[index1] - '0'
		c2 := str2[index2] - '0'
		sum := int(c1) + int(c2) + left
		if sum >= 10 {
			left = 1
		} else {
			left = 0
		}
		c3 := (sum % 10) + '0'
		result = fmt.Sprintf("%c%s", c3, result)
		index1--
		index2--
	}
	for index1 >= 0 {
		c1 := str1[index1] - '0'
		sum := int(c1) + left
		if sum >= 10 {
			left = 1
		} else {
			left = 0
		}
		c3 := (sum % 10) + '0'
		result = fmt.Sprintf("%c%s", c3, result)
		index1--
	}
	for index2 >= 0 {
		c1 := str2[index2] - '0'
		sum := int(c1) + left
		if sum >= 10 {
			left = 1
		} else {
			left = 0
		}
		c3 := (sum % 10) + '0'
		result = fmt.Sprintf("%c%s", c3, result)
		index2--
	}
	if left == 1 {
		result = fmt.Sprintf("1%s", result)
	}
	return
}

func sum_main() {
	reader := bufio.NewReader(os.Stdin)
	result, _, err := reader.ReadLine()
	if err != nil {
		fmt.Println("read from console err:", err)
	}
	strSlice := strings.Split(string(result), "+")
	if len(strSlice) != 2 {
		fmt.Println("please input a+b")
	}

	strnumber1 := strings.TrimSpace(strSlice[0])
	strnumber2 := strings.TrimSpace(strSlice[1])
	fmt.Println(multi(strnumber1, strnumber2))

}

func main() {
	// jj9()
	// ws2()
	// strs()
	// read_line()
	sum_main()
}
```